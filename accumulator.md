# Accumulators

As noted in the overview, one uses "Accumulators" to
collect information about sequentially numbered
sections, cross-references, tables of content, etc.,
then use it to render the source text with these features.
Accumulators are made of up of reducers and folds:

```elm
type alias Reducer : a -> b -> b
List.foldl : (a -> b -> b ) -> b -> List a -> b
```

Thus a `Reducer` is just a name for the type of the
first argument of a fold. Consider a reducer of the
form

```elm
Reducer a b = a -> (state, List b) -> (state, List b)
```

It fits into a fold of the form

```elm
StateReducer a b -> (state, List b) -> List a -> (state, List b)
```

Let `transform` have type `StateReducer a b`. Define

```elm
acc transformer state_ inputList =
  List.foldl transformer (state_, []) inputList
```

This function has type

```elm
Accumulator a b = state -> List a (state, List b)
```

## Accumulator.parse

Let us now discuss the accumulators used in MiniLatex.
The first of these is `Accumulator.parse`. Its function
is to take a `LatexState` and a list of paragraphs, i.e.,
a `List String`, and produce an updated `LatexState`
and a `List (List LatexExpression)`. Each element
of the latter is a `List LatexExpression` representing
the application of the MiniLatex parser to a paragraph.

```
Accumulator.parse :
    LatexState
    -> List String
    -> ( LatexState, List (List LatexExpression) )
Accumulator.parse latexState paragraphs =
    paragraphs
        |> List.foldl parseReducer ( latexState, [] )
```

The `Accumulator.parse` function applies a `List.foldl`
to a pair consisting of an initial `LatexState` and
an empty list using a `parseReducer`. The latter is
defined as follows:

```
parseReducer :
    String
    -> ( LatexState, List (List LatexExpression) )
    -> ( LatexState, List (List LatexExpression) )
parseReducer inputString ( latexState, inputList ) =
    let
        parsedInput =
            Parser.parse inputString

        newLatexState =
            latexStateReducer parsedInput latexState
    in
    ( newLatexState, inputList ++ [ parsedInput ] )
```

The `parseReducer` takes as input a string, representing a
logical paragraph of source text, and a pair consisting of
a `LatexState` and a `List (List LatexExpression`. It
parses the string and computes a new `LatexState`. Finally,
it returns a pair consisting of the new `LatexState` and
inputList with the parsedInput appended.

```
latexStateReducer : List LatexExpression -> LatexState -> LatexState
```

## Accumulator.render

```
render :
    (LatexState -> List LatexExpression -> a)
    -> LatexState
    -> List (List LatexExpression)
    -> ( LatexState, List a )
render renderer latexState paragraphs =
    paragraphs
        |> List.foldl (renderReducer renderer) ( latexState, [] )
```

```
renderReducer :
    (LatexState -> List LatexExpression -> a)
    -> List LatexExpression
    -> ( LatexState, List a )
    -> ( LatexState, List a )
renderReducer renderer input ( state, outputList ) =
    let
        newState =
            latexStateReducer input state

        renderedInput =
            renderer newState input
    in
    ( newState, outputList ++ [ renderedInput ] )
```

## LatexStateReducer

The purpose of the `latexStateReducer` is to update a given
`LatexState` using the information contained in a `List LatexExpression`,
e.g, the parse result of a paragraph.

```
latexStateReducer : List LatexExpression -> LatexState -> LatexState
latexStateReducer parsedParagraph latexState =
    let
        theInfo =
            parsedParagraph
                |> List.head
                |> Maybe.map info
                |> Maybe.withDefault (LatexInfo "null" "null" [] [])
    in
    (latexStateReducerDispatcher  theInfo) theInfo latexState
```

This a fairly complex reducer
because of the complexit of the call chain generated by `latexStateReducerDispatcher`.
In brief, the reducer looks at first `LatexExpression` in the list,
then computes a record `theInfo` which contains information about the
paragraph, e.g., does it begin with ``\section`. In that case it produces a record containing certain information about the`LatexExpression`.
Here is an example:

```
> import MiniLatex.Parser exposing(..)
> import Parser exposing(run)
> import MiniLatex.Accumulator exposing(info)
> result = run latexExpression "\\section{foo}"
Ok (Macro "section" [] [LatexList [LXString "foo"]])
> expression = Macro "section" [] [LatexList [LXString "foo"]]
> theInfo = info expression
{ name = "section", options = [], typ = "macro", value = [LatexList [LXString "Foo"]] }
    : MiniLatex.Accumulator.LatexInfo
```

What is important is that the paragraph begins with the section macro.
Consider now the definition of `latexStateReducerDispatcher` listed below.

### latexStateReducerDispatcher

```
latexStateReducerDispatcher : LatexInfo -> (LatexInfo -> LatexState -> LatexState)
latexStateReducerDispatcher theInfo =
    case Dict.get ( theInfo.typ, theInfo.name ) latexStateReducerDict of
        Just f ->
            f

        Nothing ->
            \latexInfo latexState -> latexState
```

Consider next the function call `latexStateReducerDispatcher theInfo` in the
last line of the definition of `latexStateReducer`. The result is a function
of `f` of type `LatexInfo -> LatexState -> LatexState`. Therefore
`f theInfo latexState` is a new `LatexState`. Let us see what results from this
in the example above, where `theInfo` has fields `name = "section"` and `typ = "macro"`.
According to the `latexStateReducerDict` below, the call produces
`f = SRH.setSectionCounters x y`, where `SRH` is an alias of the `StateReducerHelper` module.
Referring to that module, we find this definition.

```
updateSectionNumber : LatexInfo -> LatexState -> LatexState
updateSectionNumber info latexState =
    let
        label =
            getCounter "s1" latexState |> (\x -> x + 1) |> String.fromInt
    in
        latexState
            |> incrementCounter "s1"
            |> updateCounter "s2" 0
            |> updateCounter "s3" 0
            |> addSection (PT.unpackString info.value) label 1
```

As we see, `updateSectionNumber` increments the "s1" counter in the `latexState`
and sets the other section counters to zero. Let's see what `addSection` does:

```
LatexState.addSection : String -> String -> Int -> LatexState -> LatexState
LatexState.addSection sectionName label level latexState =
    let
        newEntry =
            TocEntry sectionName label level

        toc =
            latexState.tableOfContents ++ [ newEntry ]
    in
    { latexState | tableOfContents = toc }
```

We will not go down the rabbit hole any further, but you can see what is happening:
`LatexState.addSection` adds an entry to the `tableOfContents` field of `latexState`.
That entry contains the name of the section, a label, and its level (section, subsection, etc.).

Here is the type:

```
type alias LatexState =
    { counters : Counters
    , crossReferences : CrossReferences
    , tableOfContents : TableOfContents
    , dictionary : Dictionary
    }
```

### Example: rendering a section

To conclude this discussion, here is how a section is rendered:

```
renderSection : LatexState -> List LatexExpression -> Html msg
renderSection latexState args =
    let
        sectionName =
            MiniLatex.Render.renderArg 0 latexState args

        s1 =
            getCounter "s1" latexState

        label =
            if s1 > 0 then
                String.fromInt s1 ++ " "

            else
                ""

        ref =
            idPhrase "section" sectionName
    in
    Html.h2 (headingStyle ref 24) [ Html.text <| label ++ sectionName ]
```

In brief, consider what happens when `Accumulator.render` is run, with the `LatexState` is
initialized with the various section counters set to zero, but with other needed
data harvested from running `Accumulator.parse`, e.g., the table of contents
and the cross-references. As each section in the parsed input is encountered, the
section counter is advanced and is used to render the section with its correct
sequence number.

### latexStateReducerDict

```
latexStateReducerDict : Dict.Dict ( String, String ) (LatexInfo -> LatexState -> LatexState)
latexStateReducerDict =
    Dict.fromList
        [ ( ( "macro", "setcounter" ), \x y -> SRH.setSectionCounters x y )
        , ( ( "macro", "section" ), \x y -> SRH.updateSectionNumber x y )
        , ( ( "macro", "subsection" ), \x y -> SRH.updateSubsectionNumber x y )
        , ( ( "macro", "subsubsection" ), \x y -> SRH.updateSubsubsectionNumber x y )
        , ( ( "macro", "title" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "author" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "date" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "email" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "host" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "setclient" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "setdocid" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "macro", "revision" ), \x y -> SRH.setDictionaryItemForMacro x y )
        , ( ( "env", "theorem" ), \x y -> SRH.setTheoremNumber x y )
        , ( ( "env", "proposition" ), \x y -> SRH.setTheoremNumber x y )
        , ( ( "env", "lemma" ), \x y -> SRH.setTheoremNumber x y )
        , ( ( "env", "definition" ), \x y -> SRH.setTheoremNumber x y )
        , ( ( "env", "corollary" ), \x y -> SRH.setTheoremNumber x y )
        , ( ( "env", "equation" ), \x y -> SRH.setEquationNumber x y )
        , ( ( "env", "align" ), \x y -> SRH.setEquationNumber x y )
        , ( ( "smacro", "bibitem" ), \x y -> SRH.setBibItemXRef x y )
        ]
```

## Some conclusions

The reliance of `Accumulator.parse` and `Accumulator.render`
on the `LatexState` record, as well as the `latexStateReducerDict`
for dispatching calls to `latexStateReducer` makes it very easy
to add new features -- new macros and new environments -- that
whose rendering requires a computed state. Moreover, it is
not hard to add fields to `LatexState` in order to add new features.
Indeed, the first version of `LatexInfo` had only a `counters` field.
Others were added later as the scope of MiniLatex grew.
